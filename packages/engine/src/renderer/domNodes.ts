import type { NodeModel, PresentationModel } from "@interactive/content";
import { worldToScreen } from "../camera";

export interface DomNodeHandle {
  id: string;
  el: HTMLElement;
  update: (node: NodeModel) => void;
  destroy: () => void;
}

function setCommonStyles(el: HTMLElement, node: NodeModel) {
  el.style.position = "absolute";
  el.style.pointerEvents = "auto";
  el.style.opacity = String(node.opacity ?? 1);
  el.style.display = node.visible === false ? "none" : "block";
  el.style.transformOrigin = "50% 50%";
  el.dataset.nodeId = node.id;
  el.dataset.nodeType = node.type;
  el.dataset.anchor = node.transform.anchor ?? "";
  el.classList.add("node");
}

function applyTransform(el: HTMLElement, node: NodeModel, px: { x: number; y: number; w: number; h: number }) {
  el.style.left = `${px.x}px`;
  el.style.top = `${px.y}px`;
  el.style.width = `${px.w}px`;
  el.style.height = `${px.h}px`;
  const rot = node.transform.rotationDeg ?? 0;
  el.style.transform = `rotate(${rot}deg)`;
}

export function createDomNode(node: NodeModel): DomNodeHandle | null {
  if (node.type === "text") {
    const el = document.createElement("div");
    el.style.whiteSpace = "pre-wrap";
    el.style.color = "rgba(255,255,255,0.92)";
    el.style.fontSize = "28px";
    // Match KaTeX's \mathrm{...} look (regular weight Computer Modernâ€“like roman).
    el.style.fontWeight = "400";
    el.style.fontFamily = "KaTeX_Main, Times New Roman, serif";
    el.style.boxSizing = "border-box";
    setCommonStyles(el, node);

    const update = (n: NodeModel) => {
      if (n.type !== "text") return;
      setCommonStyles(el, n);
      const align = (n as any).align;
      el.style.textAlign = align === "right" ? "right" : align === "center" ? "center" : "left";
      // IMPORTANT:
      // The app layer may render KaTeX by setting el.innerHTML. Since this renderer runs every frame,
      // we must not overwrite innerHTML unless the raw text actually changed.
      const raw = n.text ?? "";
      if (el.dataset.rawText !== raw) {
        el.dataset.rawText = raw;
        // Provide a plain-text fallback until the app layer re-hydrates math.
        el.textContent = raw;
      }
    };

    update(node);
    return { id: node.id, el, update, destroy: () => el.remove() };
  }

  if (node.type === "qr") {
    // The actual QR image is generated by the app layer (qrcode lib) for now.
    const el = document.createElement("div");
    el.classList.add("node-qr");
    el.style.boxSizing = "border-box";

    const box = document.createElement("div");
    box.className = "qr-box";
    box.style.position = "relative";
    box.style.width = "100%";
    box.style.height = "100%";

    const canvas = document.createElement("canvas");
    canvas.className = "qr-canvas";
    canvas.style.position = "absolute";
    canvas.style.inset = "0";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.display = "none";
    (canvas.style as any).imageRendering = "pixelated";

    const img = document.createElement("img");
    img.className = "qr-img";
    img.alt = "QR";
    img.style.position = "absolute";
    img.style.inset = "0";
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "contain";
    img.style.display = "block";
    (img.style as any).imageRendering = "pixelated";
    box.append(canvas, img);
    el.append(box);

    setCommonStyles(el, node);
    const update = (n: NodeModel) => {
      setCommonStyles(el, n);
      if (n.type !== "qr") return;
      el.dataset.qrUrl = n.url;
    };
    update(node);
    return { id: node.id, el, update, destroy: () => el.remove() };
  }

  if (node.type === "htmlFrame") {
    // Important: clicks inside the iframe won't bubble to the parent document.
    // We *want* that. Selection/resize should happen on the border area around the iframe.
    const el = document.createElement("div");
    el.classList.add("node-iframe");
    el.style.boxSizing = "border-box";
    el.style.position = "absolute";
    // Important: allow handles (rotate dot) to render outside the frame bounds.
    el.style.overflow = "visible";

    const frame = document.createElement("div");
    frame.className = "iframe-frame";

    const borderPx = 10;
    const iframe = document.createElement("iframe");
    iframe.className = "iframe";
    iframe.style.position = "absolute";
    iframe.style.left = `${borderPx}px`;
    iframe.style.top = `${borderPx}px`;
    iframe.style.right = `${borderPx}px`;
    iframe.style.bottom = `${borderPx}px`;
    iframe.style.width = `calc(100% - ${borderPx * 2}px)`;
    iframe.style.height = `calc(100% - ${borderPx * 2}px)`;
    iframe.style.border = "0";
    iframe.style.background = "transparent";
    iframe.loading = "lazy";

    frame.appendChild(iframe);
    el.appendChild(frame);
    setCommonStyles(el, node);

    const update = (n: NodeModel) => {
      setCommonStyles(el, n);
      if (n.type !== "htmlFrame") return;
      iframe.src = n.src;
    };
    update(node);
    return { id: node.id, el, update, destroy: () => el.remove() };
  }

  if (node.type === "image") {
    const el = document.createElement("div");
    el.classList.add("node-image");
    el.style.boxSizing = "border-box";

    // Inner frame so we can clip rounded corners without clipping resize/rotate handles.
    const frame = document.createElement("div");
    frame.className = "image-frame";
    frame.style.position = "absolute";
    frame.style.inset = "0";
    frame.style.overflow = "hidden";
    frame.style.borderRadius = "12px";

    const canvas = document.createElement("canvas");
    canvas.className = "image-canvas";
    canvas.style.position = "absolute";
    canvas.style.inset = "0";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.display = "none";
    (canvas.style as any).imageRendering = "pixelated";

    const img = document.createElement("img");
    img.className = "image";
    img.alt = "image";
    img.style.position = "absolute";
    img.style.inset = "0";
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "contain";
    img.style.display = "block";
    img.decoding = "async";
    img.loading = "lazy";
    (img.style as any).imageRendering = "pixelated";
    frame.append(canvas, img);
    el.append(frame);

    setCommonStyles(el, node);
    const update = (n: NodeModel) => {
      setCommonStyles(el, n);
      if (n.type !== "image") return;
      img.src = n.src;
    };
    update(node);
    return { id: node.id, el, update, destroy: () => el.remove() };
  }

  if (node.type === "timer") {
    const el = document.createElement("div");
    el.classList.add("node-timer");
    el.style.boxSizing = "border-box";

    const frame = document.createElement("div");
    frame.className = "timer-frame";
    frame.style.position = "absolute";
    frame.style.inset = "0";
    frame.style.overflow = "hidden";
    frame.style.borderRadius = "12px";

    const header = document.createElement("div");
    header.className = "timer-header";
    header.style.position = "absolute";
    header.style.left = "10px";
    header.style.right = "10px";
    header.style.top = "10px";
    header.style.display = "flex";
    header.style.gap = "10px";
    header.style.alignItems = "center";
    header.style.pointerEvents = "auto";

    const startBtn = document.createElement("button");
    startBtn.className = "timer-btn primary";
    startBtn.type = "button";
    startBtn.textContent = "Start";
    startBtn.dataset.action = "timer-startstop";

    const resetBtn = document.createElement("button");
    resetBtn.className = "timer-btn";
    resetBtn.type = "button";
    resetBtn.textContent = "Reset";
    resetBtn.dataset.action = "timer-reset";

    const status = document.createElement("div");
    status.className = "timer-status";
    status.textContent = "Stopped";

    header.append(startBtn, resetBtn, status);

    const canvas = document.createElement("canvas");
    canvas.className = "timer-canvas";
    canvas.style.position = "absolute";
    canvas.style.inset = "0";
    canvas.style.width = "100%";
    canvas.style.height = "100%";

    frame.append(canvas, header);
    el.append(frame);

    setCommonStyles(el, node);
    const update = (n: NodeModel) => {
      setCommonStyles(el, n);
      if (n.type !== "timer") return;
      el.dataset.showTime = String(!!n.showTime);
      el.dataset.barColor = n.barColor ?? "orange";
      el.dataset.lineColor = n.lineColor ?? "green";
      el.dataset.stat = n.stat ?? "gaussian";
      if (typeof (n as any).minS === "number") el.dataset.minS = String((n as any).minS);
      else delete (el.dataset as any).minS;
      if (typeof (n as any).maxS === "number") el.dataset.maxS = String((n as any).maxS);
      else delete (el.dataset as any).maxS;
      if (typeof (n as any).binSizeS === "number") el.dataset.binSizeS = String((n as any).binSizeS);
      else delete (el.dataset as any).binSizeS;
    };
    update(node);
    return { id: node.id, el, update, destroy: () => el.remove() };
  }

  return null;
}

function anchorOffsetPx(anchor: string | undefined, wPx: number, hPx: number) {
  switch (anchor) {
    case "center":
    case "centerCenter":
      return { dx: -wPx / 2, dy: -hPx / 2 };
    case "top":
    case "topCenter":
      return { dx: -wPx / 2, dy: 0 };
    case "bottom":
    case "bottomCenter":
      return { dx: -wPx / 2, dy: -hPx };
    case "left":
    case "centerLeft":
      return { dx: 0, dy: -hPx / 2 };
    case "right":
    case "centerRight":
      return { dx: -wPx, dy: -hPx / 2 };
    case "topRight":
      return { dx: -wPx, dy: 0 };
    case "bottomLeft":
      return { dx: 0, dy: -hPx };
    case "bottomRight":
      return { dx: -wPx, dy: -hPx };
    case "topLeft":
    default:
      return { dx: 0, dy: 0 };
  }
}

export function layoutDomNodes(args: {
  model: PresentationModel;
  domNodes: Map<string, DomNodeHandle>;
  overlayEl: HTMLElement;
  camera: { cx: number; cy: number; zoom: number };
  screen: { w: number; h: number };
  timeMs: number;
  animationsEnabled: boolean;
}) {
  const { model, domNodes, overlayEl, camera, screen, timeMs, animationsEnabled } = args;
  const debugAnim =
    new URLSearchParams(window.location.search).get("debugAnim") === "1" || localStorage.getItem("ip_debug_anim") === "1";
  const dlog = (...a: any[]) => {
    if (!debugAnim) return;
    // eslint-disable-next-line no-console
    console.log("[ip][anim]", ...a);
  };
  const dpr = window.devicePixelRatio || 1;

  // Pixelate helper: `p` is expected to already be STEP-QUANTIZED (e.g. 0, 0.05, 0.10, ... 1.0).
  const setPixelate = (hostEl: HTMLElement, pxW: number, pxH: number, p: number, steps = 20) => {
    const canvas = hostEl.querySelector<HTMLCanvasElement>("canvas.qr-canvas, canvas.image-canvas");
    const img = hostEl.querySelector<HTMLImageElement>("img.qr-img, img.image");
    if (!canvas || !img) return;

    const pp = Math.max(0, Math.min(1, p));
    if (p >= 1) {
      canvas.style.display = "none";
      canvas.style.opacity = "0";
      img.style.opacity = "1";
      delete (hostEl.dataset as any).pixW;
      delete (hostEl.dataset as any).pixH;
      return;
    }

    // Important: if the image isn't loaded yet, keep fully transparent to avoid any "flash".
    if (!img.complete || img.naturalWidth <= 0) {
      canvas.style.display = "block";
      canvas.style.opacity = "0";
      img.style.opacity = "0";
      return;
    }

    // Alpha is step-quantized and synced to resolution.
    canvas.style.opacity = String(pp);
    canvas.style.display = "block";
    img.style.opacity = "0";

    // Main canvas always matches element resolution; we pixelate via a low-res offscreen canvas.
    const W = Math.max(2, Math.min(4096, Math.round(pxW * dpr)));
    const H = Math.max(2, Math.min(4096, Math.round(pxH * dpr)));
    if (canvas.width !== W || canvas.height !== H) {
      canvas.width = W;
      canvas.height = H;
    }

    // Resolution ramps up step-wise, synced to alpha.
    // Minimum resolution is 1/steps to match "1 step == 1/steps alpha".
    const resFactor = Math.max(1 / Math.max(1, steps), Math.min(1, pp));
    const smallW = Math.max(2, Math.round(W * resFactor));
    const smallH = Math.max(2, Math.round(H * resFactor));

    const anyHost = hostEl as any;
    let off: HTMLCanvasElement = anyHost.__pixOffscreen;
    if (!off) {
      off = document.createElement("canvas");
      anyHost.__pixOffscreen = off;
    }
    if (off.width !== smallW || off.height !== smallH) {
      off.width = smallW;
      off.height = smallH;
    }

    const offCtx = off.getContext("2d");
    const ctx = canvas.getContext("2d");
    if (!offCtx || !ctx) return;
    (offCtx as any).imageSmoothingEnabled = true;
    (ctx as any).imageSmoothingEnabled = false;

    const iw = img.naturalWidth;
    const ih = img.naturalHeight;
    const s0 = Math.min(smallW / iw, smallH / ih);
    const dw0 = iw * s0;
    const dh0 = ih * s0;
    const dx0 = (smallW - dw0) / 2;
    const dy0 = (smallH - dh0) / 2;

    offCtx.clearRect(0, 0, smallW, smallH);
    offCtx.drawImage(img, dx0, dy0, dw0, dh0);

    ctx.clearRect(0, 0, W, H);
    ctx.drawImage(off, 0, 0, smallW, smallH, 0, 0, W, H);
  };

  for (const node of model.nodes) {
    const handle = domNodes.get(node.id);
    if (!handle) continue;

    let px: { x: number; y: number; w: number; h: number };

    if (node.space === "world") {
      const wPx = node.transform.w * camera.zoom;
      const hPx = node.transform.h * camera.zoom;
      const p = worldToScreen({ x: node.transform.x, y: node.transform.y }, camera, screen);
      const { dx, dy } = anchorOffsetPx(node.transform.anchor, wPx, hPx);
      px = { x: p.x + dx, y: p.y + dy, w: wPx, h: hPx };
    } else {
      px = { x: node.transform.x, y: node.transform.y, w: node.transform.w, h: node.transform.h };
    }

    // Cull if < 1 px on either dimension.
    if (px.w < 1 || px.h < 1) {
      handle.el.style.display = "none";
      continue;
    }

    if (!handle.el.isConnected) overlayEl.appendChild(handle.el);
    applyTransform(handle.el, node, px);

    // If the node is hidden, do NOT advance enter animations in the background.
    // (Otherwise pixelate/fade can "finish" while invisible, and later appear instantly.)
    if (node.visible === false) {
      handle.update(node);
      continue;
    }

    // Make text scale with world zoom AND with its own geometry size (so resizing the box scales the font).
    if (node.type === "text") {
      const z = node.space === "world" ? camera.zoom : 1;
      // Heuristic: font size tracks the node's height. (Keeps proportional scaling when resizing corners.)
      const fontPx = Math.max(1, (node.transform.h ?? 40) * 0.6 * z);
      handle.el.style.fontSize = `${fontPx}px`;
    }

    // Intro animations (appear)
    const appear: any = (node as any).appear;
    const disappear: any = (node as any).disappear;

    // Detect visibility edges so enter animations start deterministically on "show".
    // This avoids timing-sensitive behavior (e.g. pressing ArrowRight before the image loads).
    const visNow = node.visible !== false;
    const visPrev = handle.el.dataset.prevVisible === "1";
    if (visNow && !visPrev) {
      // Became visible: reset any prior animation state.
      delete (handle.el.dataset as any).animInStartMs;
      delete (handle.el.dataset as any).pixAnimStartMs;
      delete (handle.el.dataset as any).pixAnimDone;
      delete (handle.el.dataset as any).exitStartMs;
      dlog("visible->true reset", node.id, { timeMs });
    }
    handle.el.dataset.prevVisible = visNow ? "1" : "0";

    // Exit animation (driven by dataset.exitStartMs set by presenter controller)
    if (animationsEnabled && disappear && typeof disappear === "object" && disappear.kind && disappear.kind !== "none") {
      const exitStart = Number(handle.el.dataset.exitStartMs ?? "");
      if (!Number.isNaN(exitStart)) {
        const dur = Number(disappear.durationMs ?? 0);
        const delay = Number(disappear.delayMs ?? 0);
        const t = dur > 0 ? (timeMs - (exitStart + delay)) / dur : 1;
        const p = Math.max(0, Math.min(1, t));

        if (disappear.kind === "direct") {
          // No visual effect; controller will hide immediately.
        } else if (disappear.kind === "fade") {
          const from = String(disappear.from ?? "all");
          const borderFrac = Math.max(0, Math.min(0.49, Number(disappear.borderFrac ?? 0.2)));
          // p=0 => fully visible, p=1 => fully gone.
          const front = (1 - p) * 100;
          const lead = Math.max(0, front - borderFrac * 100);

          if (from === "all") {
            handle.el.style.opacity = String(1 - p);
            (handle.el.style as any).maskImage = "";
            (handle.el.style as any).webkitMaskImage = "";
          } else {
            handle.el.style.opacity = "1";
            let mask = "";
            if (from === "left") {
              // Keep right side; fade boundary moves left->right while disappearing.
              mask = `linear-gradient(to right, rgba(0,0,0,1) 0%, rgba(0,0,0,1) ${lead}%, rgba(0,0,0,0) ${front}%, rgba(0,0,0,0) 100%)`;
            } else if (from === "right") {
              const f = 100 - front;
              const l = Math.min(100, f + borderFrac * 100);
              mask = `linear-gradient(to right, rgba(0,0,0,0) 0%, rgba(0,0,0,0) ${f}%, rgba(0,0,0,1) ${l}%, rgba(0,0,0,1) 100%)`;
            } else if (from === "top") {
              mask = `linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,1) ${lead}%, rgba(0,0,0,0) ${front}%, rgba(0,0,0,0) 100%)`;
            } else if (from === "bottom") {
              const f = 100 - front;
              const l = Math.min(100, f + borderFrac * 100);
              mask = `linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0) ${f}%, rgba(0,0,0,1) ${l}%, rgba(0,0,0,1) 100%)`;
            }
            (handle.el.style as any).maskImage = mask;
            (handle.el.style as any).webkitMaskImage = mask;
          }
        } else if (disappear.kind === "pixelate") {
          // Pixelate out by ramping DOWN resolution.
          setPixelate(handle.el, px.w, px.h, 1 - p);
          handle.el.style.opacity = "1";
          (handle.el.style as any).maskImage = "";
          (handle.el.style as any).webkitMaskImage = "";
        }

        if (p >= 1) {
          // Let controller flip node.visible=false; clear local state.
          delete (handle.el.dataset as any).exitStartMs;
          handle.el.style.opacity = "1";
          (handle.el.style as any).maskImage = "";
          (handle.el.style as any).webkitMaskImage = "";
          setPixelate(handle.el, px.w, px.h, 1);
        }

        // While exiting, skip enter animation
        handle.update(node);
        continue;
      }
    }

    if (animationsEnabled && appear && typeof appear === "object" && appear.kind && appear.kind !== "none") {
      // Some specs (e.g. authored via UI) might omit durationMs; treat that as a default
      // so animations don't silently become "instant".
      let dur = Number(appear.durationMs ?? 0);
      const delay = Number(appear.delayMs ?? 0);
      if (appear.kind === "pixelate" && dur <= 0) dur = 800;
      if (appear.kind === "fade" && dur <= 0) dur = 800;
      if (appear.kind === "direct") {
        handle.el.style.opacity = "1";
        (handle.el.style as any).maskImage = "";
        (handle.el.style as any).webkitMaskImage = "";
      } else
      if (dur > 0) {
        if (!handle.el.dataset.animInStartMs) {
          // Store the absolute start time (in engine timeMs), not just the delay.
          handle.el.dataset.animInStartMs = String(timeMs + delay);
        }
        const start = Number(handle.el.dataset.animInStartMs ?? "0");
        const t = (timeMs - start) / dur;
        const p = Math.max(0, Math.min(1, t));

        if (appear.kind === "fade") {
          const from = String(appear.from ?? "all");
          const borderFrac = Math.max(0, Math.min(0.49, Number(appear.borderFrac ?? 0.2)));

          if (p >= 1) {
            handle.el.style.opacity = "1";
            (handle.el.style as any).maskImage = "";
            (handle.el.style as any).webkitMaskImage = "";
          } else if (from === "all") {
            handle.el.style.opacity = String(p);
            (handle.el.style as any).maskImage = "";
            (handle.el.style as any).webkitMaskImage = "";
          } else {
            handle.el.style.opacity = "1";
            const front = p * 100;
            const lead = Math.max(0, front - borderFrac * 100);

            let mask = "";
            if (from === "left") {
              mask = `linear-gradient(to right, rgba(0,0,0,1) 0%, rgba(0,0,0,1) ${lead}%, rgba(0,0,0,0) ${front}%, rgba(0,0,0,0) 100%)`;
            } else if (from === "right") {
              const f = 100 - front;
              const l = Math.min(100, f + borderFrac * 100);
              mask = `linear-gradient(to right, rgba(0,0,0,0) 0%, rgba(0,0,0,0) ${f}%, rgba(0,0,0,1) ${l}%, rgba(0,0,0,1) 100%)`;
            } else if (from === "top") {
              mask = `linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,1) ${lead}%, rgba(0,0,0,0) ${front}%, rgba(0,0,0,0) 100%)`;
            } else if (from === "bottom") {
              const f = 100 - front;
              const l = Math.min(100, f + borderFrac * 100);
              mask = `linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,0) ${f}%, rgba(0,0,0,1) ${l}%, rgba(0,0,0,1) 100%)`;
            }

            (handle.el.style as any).maskImage = mask;
            (handle.el.style as any).webkitMaskImage = mask;
          }
        } else if (appear.kind === "pixelate") {
          // Pixelate must be strictly monotonic and step-synced.
          // We start the animation clock when the image is actually ready (loaded).
          const img = handle.el.querySelector<HTMLImageElement>("img.qr-img, img.image");
          const ready = !!img && img.complete && img.naturalWidth > 0;

          // If we already completed once for this visibility span, do not restart.
          if (handle.el.dataset.pixAnimDone === "1") {
            setPixelate(handle.el, px.w, px.h, 1);
            handle.el.style.opacity = "1";
            (handle.el.style as any).maskImage = "";
            (handle.el.style as any).webkitMaskImage = "";
            handle.update(node);
            continue;
          }

          // Use a dedicated clock so we don't fight with the generic animInStartMs used by fade.
          if (!handle.el.dataset.pixAnimStartMs) {
            // If Live cue requested pixelate but the image isn't ready yet, hold p=0 and DO NOT advance time.
            if (!ready) {
              setPixelate(handle.el, px.w, px.h, 0);
              handle.el.style.opacity = "1";
              (handle.el.style as any).maskImage = "";
              (handle.el.style as any).webkitMaskImage = "";
              handle.update(node);
              continue;
            }
            handle.el.dataset.pixAnimStartMs = String(timeMs + delay);
            dlog("pixelate start", node.id, { start: handle.el.dataset.pixAnimStartMs, dur, delay, px: { w: px.w, h: px.h } });
          }
          // If we were explicitly asked to pixelate (by cue) we start as soon as ready.
          if (handle.el.dataset.pixPending === "1" && ready && !handle.el.dataset.pixAnimStartMs) {
            delete (handle.el.dataset as any).pixPending;
            handle.el.dataset.pixAnimStartMs = String(timeMs + delay);
            dlog("pixelate start(pending)", node.id, { start: handle.el.dataset.pixAnimStartMs, dur, delay });
          }

          const startPix = Number(handle.el.dataset.pixAnimStartMs ?? "0");
          const elapsed = Math.max(0, timeMs - startPix);
          const steps = Math.max(2, Number((model as any).defaults?.pixelateSteps ?? 20));
          const stepDur = dur > 0 ? dur / steps : 0;
          const stepIdx = stepDur > 0 ? Math.max(0, Math.min(steps, Math.floor(elapsed / stepDur))) : steps;
          const stepP = stepIdx / steps;

          setPixelate(handle.el, px.w, px.h, stepP, steps);
          if (stepIdx >= steps) {
            delete (handle.el.dataset as any).pixAnimStartMs;
            handle.el.dataset.pixAnimDone = "1";
            dlog("pixelate done", node.id, { timeMs });
          }

          handle.el.style.opacity = "1";
          (handle.el.style as any).maskImage = "";
          (handle.el.style as any).webkitMaskImage = "";
        }
      }
    }

    handle.update(node);
  }
}


